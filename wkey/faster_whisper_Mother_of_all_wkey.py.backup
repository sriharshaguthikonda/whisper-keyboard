import os
import time
import threading
import pyautogui
import winsound
import clipboard

# import pyperclip
import numpy as np
import sounddevice as sd
import pythoncom
from scipy.io.wavfile import write as wav_write


import groq
from groq import Groq

import queue
from pynput.keyboard import Controller as KeyboardController, Key, Listener
from dotenv import load_dotenv

from faster_whisper import WhisperModel
from voice_commands import execute_command
from pause_all import is_sound_playing_windows_processing  # ,is_sound_playing_windows


from ctypes import cast, POINTER
from comtypes import CLSCTX_ALL
from pycaw.pycaw import AudioUtilities, IAudioEndpointVolume

# Initial setup and global variables
initial_volume = None  # Variable to store initial volume
transcript_queue = queue.Queue()
audio_buffer_queue = queue.Queue()
load_dotenv()
key_label = os.environ.get("WKEY", "f24")
RECORD_KEY = Key[key_label]
keyboard_controller = KeyboardController()
recording = False
stream = None
audio_buffer = np.array([], dtype="float32")
sample_rate = 8000
model = WhisperModel("small.en", device="cuda", num_workers=8)
play_pause_pressed = False
something_is_playing = False

# Define beep sounds
START_BEEP = (880, 200)  # Frequency in Hz, Duration in ms
STOP_BEEP = (440, 200)  # Lower frequency for stop
PASTE_BEEP = (660, 200)  # Intermediate frequency for paste

# Locks for synchronization
recording_lock = threading.Lock()
audio_data_lock = threading.Lock()


def get_current_volume():
    devices = AudioUtilities.GetSpeakers()
    interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)
    volume = cast(interface, POINTER(IAudioEndpointVolume))
    return volume.GetMasterVolumeLevelScalar()


def set_volume(volume_level):
    devices = AudioUtilities.GetSpeakers()
    interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)
    volume = cast(interface, POINTER(IAudioEndpointVolume))
    volume.SetMasterVolumeLevelScalar(volume_level, None)


def decrease_volume_all():
    global initial_volume
    if initial_volume is None:
        initial_volume = get_current_volume()
    print(f"Decreasing volume from {initial_volume * 100}% to 10%")
    set_volume(0.1)  # Set volume to 10%


def restore_volume_all():
    global initial_volume
    if initial_volume is not None:
        print(f"Restoring volume to {initial_volume * 100}%")
        set_volume(initial_volume)  # Restore to initial volume


def callback(indata, frames, time, status):
    global audio_buffer
    if status:
        print(status)
    with audio_data_lock:
        if recording:
            audio_buffer = np.append(audio_buffer, indata.copy())


stream = sd.InputStream(
    callback=callback,
    device=None,
    channels=1,
    samplerate=sample_rate,
    blocksize=int(sample_rate * 0.1),
)


def monitor_sound_processing():
    pythoncom.CoInitialize()
    global something_is_playing
    while True:
        if not recording:
            something_is_playing = is_sound_playing_windows_processing(
                something_is_playing
            )


def on_press(key):
    global recording
    global play_pause_pressed
    global something_is_playing
    global audio_buffer
    global stream

    if key == RECORD_KEY and not recording:
        try:
            if stream and stream.active:
                stream.stop()
            stream.close()
        except NameError:
            pass

        try:
            device_info = sd.default.device
            print(f"Using device: {device_info}")
            stream = sd.InputStream(
                callback=callback,
                device=None,
                channels=1,
                samplerate=sample_rate,
                blocksize=int(sample_rate * 0.1),
            )
            stream.start()
        except Exception as e:
            print(f"Failed to start stream: {e}")
            time.sleep(2)
        if something_is_playing:
            print("Stream started")
            decrease_volume_all()
            play_pause_pressed = True
        else:
            print("Stream started")

        beep(START_BEEP)
        with recording_lock:
            recording = True
        print("Listening...")


def on_release(key):
    global stream
    global recording
    global play_pause_pressed
    global audio_buffer

    if key == RECORD_KEY and recording:
        if stream.active:
            audio_buffer_queue.put(audio_buffer)
            stream.stop()
            stream.close()
            audio_buffer = np.array([], dtype="float32")

        if play_pause_pressed:
            restore_volume_all()
            play_pause_pressed = False
        beep(STOP_BEEP)
        with recording_lock:
            recording = False
        print("Transcribing...")


api_key = os.getenv("GROQ_API_KEY")
client = Groq(api_key=api_key)


def transcribe_with_groq(audio_buffer, filename="audio_buffer.wav"):
    try:
        wav_write(filename, sample_rate, audio_buffer)
        with open(filename, "rb") as file:
            transcription = client.audio.transcriptions.create(
                file=(filename, file.read()),
                model="whisper-large-v3",
                prompt="Specify context or spelling",
                response_format="json",
                language="en",
                temperature=0.0,
            )
        return transcription.text
    except Exception as e:
        print(f"Groq API error: {e}")
        raise


def transcribe_with_local_model(audio_buffer):
    segments, info = model.transcribe(
        audio_buffer, language="en", suppress_blank=True, vad_filter=True
    )
    transcript = " ".join([segment["text"] for segment in segments])
    return transcript


def process_audio_async():
    while True:
        try:
            audio_buffer_for_processing = audio_buffer_queue.get(timeout=5)
            if audio_buffer_for_processing is None:
                break
            try:
                transcript = transcribe_with_groq(audio_buffer_for_processing)
            except groq.RateLimitError:
                print("Groq API rate limit reached, switching to local transcription.")
                transcript = transcribe_with_local_model(audio_buffer_for_processing)
            transcript_queue.put(transcript)
            print(transcript)
        except queue.Empty:
            continue
        except Exception as e:
            print(f"An error occurred during transcription: {e}")


def start_listener():
    try:
        with Listener(on_press=on_press, on_release=on_release) as listener:
            listener.join()
    except KeyboardInterrupt:
        print("Ctrl+C pressed. Exiting...")


def beep(sound):
    winsound.Beep(sound[0], sound[1])


# Function to clean transcript and paste it
def clean_transcript():
    while True:
        try:
            # Get the transcript from the queue
            transcript = transcript_queue.get()

            # Save the original clipboard content
            original_clipboard_content = clipboard.paste()

            # Set new clipboard content
            clipboard.copy(transcript)

            # Use pyautogui to paste
            pyautogui.hotkey("ctrl", "v")
            beep(PASTE_BEEP)
            print("Transcript pasted")

            # Restore the original clipboard content with a slight delay
            time.sleep(0.1)
            clipboard.copy(original_clipboard_content)

            # Re-copy the transcript to make it the most recent clipboard content
            time.sleep(0.1)
            clipboard.copy(transcript)

        except Exception as e:
            print(f"An error occurred in clean_transcript: {e}")


def main():
    global stream
    print("wkey is active. Hold down", RECORD_KEY, " to start dictating.")

    try:
        threading.Thread(target=monitor_sound_processing, daemon=True).start()
        threading.Thread(target=clean_transcript, daemon=True).start()
        threading.Thread(target=process_audio_async, daemon=True).start()

        with stream:
            with Listener(on_press=on_press, on_release=on_release) as listener:
                listener.join()
    except KeyboardInterrupt:
        print("Ctrl+C pressed. Exiting...")
    finally:
        if stream:
            if stream.active:
                stream.stop()
            stream.close()
        restore_volume_all()
        print("Cleanup completed. Exiting...")


if __name__ == "__main__":
    main()
